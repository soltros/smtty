#!/usr/bin/env bash
# smtty - Steam Machine launcher (gamescope-only)
# Can be run from a bare TTY or from an X11/Wayland session (Hyprland, Sway, KDE, GNOME, etc.).
# Recommended install location:
#   - $HOME/.local/bin/smtty  (user)
#   - /usr/local/bin/smtty    (system-wide)

set -euo pipefail

# ---------------- Steam command (Gamepad UI) ----------------
# Optional override:
#   STEAM_CMD_OVERRIDE='steam -gamepadui -nochatui'
if [[ "${STEAM_CMD_OVERRIDE-}" != "" ]]; then
  read -ra STEAM_CMD_ARR <<<"$STEAM_CMD_OVERRIDE"
else
  STEAM_CMD_ARR=(steam -gamepadui)
fi

# Steam installation type (set during detection)
STEAM_TYPE=""  # "native" or "flatpak"

# Session mode: "kms" (bare VT) or "nested" (X11/Wayland compositor)
SESSION_MODE="kms"

# ---------------- config paths ----------------
CONFIG_DIR="$HOME/.config/smtty"
CONFIG_FILE="$CONFIG_DIR/config"

# ---------------- state ----------------
DRM_SHORT=""
DRM_NATIVE_MODE=""
NATIVE_W=0
NATIVE_H=0

GAME_W=0
GAME_H=0
STRETCH_FLAG="none"   # "none" | "stretch"

G_FPS=0               # gamescope -r (target display refresh, Hz; 0 = unlimited)

# VRR / HDR / cursor flags
ADAPTIVE_SYNC=0          # 0/1 -> --adaptive-sync
ENABLE_GAMESCOPE_HDR=0   # 0/1 -> --hdr-enabled (+ ITM)
GAMESCOPE_HDR_NITS=1000  # used with --hdr-itm-target-nits
FORCE_GRAB_CURSOR=0      # 0/1 -> --force-grab-cursor (KMS only)

# PipeWire debug control for gamescope
# "inherit" = do not set PIPEWIRE_DEBUG (respect system / environment)
# "0"       = errors only (quiet)
# "1"       = errors + warnings
# "2"       = info
# "3"       = verbose debug
PIPEWIRE_DEBUG_MODE="inherit"

MISSING_CMDS=()
HAVE_CONFIG=0

# flags
FLAG_HELP=0
FLAG_NEW=0
FLAG_LAST=0
FLAG_PRINT=0
FLAG_KILL=0
FLAG_DETACH=0

# ---------------- helpers ----------------
require_cmd() {
  local cmd=$1
  if ! command -v "$cmd" >/dev/null 2>&1; then
    MISSING_CMDS+=("$cmd")
  fi
}

prompt_select() {
  local prompt=$1
  shift
  local count=$#
  local i=1
  local opt
  for opt in "$@"; do
    printf '  [%d] %s\n' "$i" "$opt"
    i=$((i + 1))
  done
  local sel
  while :; do
    read -rp "$prompt " sel || exit 1
    if [[ ! "$sel" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( sel >= 1 && sel <= count )); then
      REPLY=$sel
      return 0
    fi
    echo "Out of range."
  done
}

read_default() {
  local prompt=$1
  local def=$2
  local val
  read -rp "$prompt [$def]: " val || exit 1
  if [[ -z "$val" ]]; then
    printf '%s\n' "$def"
  else
    printf '%s\n' "$val"
  fi
}

print_help() {
  cat <<EOF
smtty - Steam Machine launcher (gamescope-only)

Usage:
  smtty [options]

Options:
  -h        Show this help and exit.
  -n        New interactive setup, ignore saved config.
  -l        Use last saved config immediately (no questions).
  -p        Print saved config summary and exit.
  -k        Kill any running gamescope processes and exit.
  -d        Detach: start gamescope/Steam in the background and return immediately.

Environment:
  STEAM_CMD_OVERRIDE='steam -gamepadui'
      Override the Steam command used (default is auto-chosen native/flatpak).
  PIPEWIRE_DEBUG
      If smtty PipeWire mode is "inherit", this is passed through unchanged.
      Otherwise, smtty overrides it with the selected numeric level.

Config:
  $CONFIG_FILE
      Stores DRM output, resolution, stretch flag, gamescope display rate,
      VRR / HDR settings, PipeWire debug level, and Steam type.

Notes:
  - Can be run from a bare TTY (KMS mode) or from inside a compositor
    (Hyprland, Sway, KDE, GNOME, etc.). Resolution and scaling are always
    applied via gamescope runtime flags, not permanent display config writes.
EOF
}

print_config_summary() {
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config at $CONFIG_FILE"
    return
  fi

  echo "Saved smtty config ($CONFIG_FILE):"
  echo "  Steam type:               ${STEAM_TYPE:-native}"
  echo "  DRM output:               $DRM_SHORT"
  echo "  Native mode:              $DRM_NATIVE_MODE"
  echo "  Game resolution:          ${GAME_W}x${GAME_H}"
  echo "  Stretch flag:             $STRETCH_FLAG"
  echo "  gamescope display rate:   $G_FPS Hz (0 = unlimited)"
  echo "  gamescope adaptive-sync:  $ADAPTIVE_SYNC"
  echo "  gamescope HDR enabled:    $ENABLE_GAMESCOPE_HDR"
  echo "  gamescope HDR target nits $GAMESCOPE_HDR_NITS"
  echo "  gamescope force grab:     $FORCE_GRAB_CURSOR"
  echo "  PipeWire debug mode:      $PIPEWIRE_DEBUG_MODE (inherit or 0â€“3)"
}

save_config() {
  mkdir -p "$CONFIG_DIR"
  cat >"$CONFIG_FILE" <<EOF
DRM_SHORT=$DRM_SHORT
DRM_NATIVE_MODE=$DRM_NATIVE_MODE
NATIVE_W=$NATIVE_W
NATIVE_H=$NATIVE_H
GAME_W=$GAME_W
GAME_H=$GAME_H
STRETCH_FLAG=$STRETCH_FLAG
G_FPS=$G_FPS
STEAM_TYPE=$STEAM_TYPE
ADAPTIVE_SYNC=$ADAPTIVE_SYNC
ENABLE_GAMESCOPE_HDR=$ENABLE_GAMESCOPE_HDR
GAMESCOPE_HDR_NITS=$GAMESCOPE_HDR_NITS
FORCE_GRAB_CURSOR=$FORCE_GRAB_CURSOR
PIPEWIRE_DEBUG_MODE=$PIPEWIRE_DEBUG_MODE
EOF
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    . "$CONFIG_FILE"
    HAVE_CONFIG=1
  fi
  # Backward compatibility: old configs won't have these
  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-inherit}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}
}

detect_session_mode() {
  if [[ -n "${WAYLAND_DISPLAY-}" || -n "${DISPLAY-}" ]]; then
    SESSION_MODE="nested"
  else
    SESSION_MODE="kms"
  fi
}

# ---------------- output / resolution selection ----------------
choose_drm_output() {
  echo "Detected *connected* DRM outputs:"

  local entries=()
  local idx=1
  local status_path status dir modes_path short native_line

  for status_path in /sys/class/drm/card*-*/status; do
    [[ -f "$status_path" ]] || continue
    status=$(<"$status_path")
    [[ "$status" == "connected" ]] || continue

    dir=${status_path%/status}
    modes_path="$dir/modes"
    [[ -f "$modes_path" ]] || continue

    short=${dir##*/}
    short=${short#card*-}

    # Read all modes and pick the largest WxH by area
    native_line="unknown"
    local max_area=0
    local mline mw mh area
    while IFS= read -r mline; do
      [[ -z "$mline" ]] && continue
      if [[ "$mline" =~ ([0-9]+)x([0-9]+) ]]; then
        mw=${BASH_REMATCH[1]}
        mh=${BASH_REMATCH[2]}
        area=$(( mw * mh ))
        if (( area > max_area )); then
          max_area=$area
          native_line="$mline"
        fi
      fi
    done <"$modes_path"

    entries+=("$short:$native_line")
    printf '  [%d] %s (native: %s)\n' "$idx" "$short" "$native_line"
    idx=$((idx + 1))
  done

  if ((${#entries[@]} == 0)); then
    echo "No *connected* DRM outputs found under /sys/class/drm."
    exit 1
  fi

  local choice
  while :; do
    read -rp "Select output [1-${#entries[@]}]: " choice || exit 1
    if [[ ! "$choice" =~ ^[0-9]+$ ]]; then
      echo "Enter a number."
      continue
    fi
    if (( choice >= 1 && choice <= ${#entries[@]} )); then
      break
    fi
    echo "Out of range."
  done

  local chosen=${entries[choice-1]}
  DRM_SHORT=${chosen%%:*}
  DRM_NATIVE_MODE=${chosen#*:}

  local base=${DRM_NATIVE_MODE%%@*}
  if [[ "$base" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    NATIVE_W=${BASH_REMATCH[1]}
    NATIVE_H=${BASH_REMATCH[2]}
  else
    echo "Failed to parse native mode \"$DRM_NATIVE_MODE\"; expected WxH[@Hz]."
    exit 1
  fi

  echo
  echo "Using DRM output: $DRM_SHORT (native ${NATIVE_W}x${NATIVE_H})"
  echo "Session mode:     $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo
  if [[ "$SESSION_MODE" == "nested" ]]; then
    echo "Note: running under a compositor. gamescope will be nested as a window"
    echo "      or fullscreen surface. Physical monitor resolution is not changed,"
    echo "      but gamescope still controls internal and outer resolutions/scaling."
    echo
  fi
}

choose_resolution_profile() {
  GAME_W=$NATIVE_W
  GAME_H=$NATIVE_H
  STRETCH_FLAG="none"

  if [[ $NATIVE_W -eq 1920 && $NATIVE_H -eq 1080 ]]; then
    echo "Resolution profile for 1080p 16:9:"
    prompt_select "Choose profile:" \
      "Native 1920x1080 (no stretch)" \
      "1352x1080 (4:3 stretched)" \
      "1680x1050 (16:10 stretched)" \
      "Custom"
    case $REPLY in
      1) GAME_W=1920; GAME_H=1080; STRETCH_FLAG="none" ;;
      2) GAME_W=1352; GAME_H=1080; STRETCH_FLAG="stretch" ;;
      3) GAME_W=1680; GAME_H=1050; STRETCH_FLAG="stretch" ;;
      4) ;;
    esac
  elif [[ $NATIVE_W -eq 2560 && $NATIVE_H -eq 1440 ]]; then
    echo "Resolution profile for 1440p 16:9:"
    prompt_select "Choose profile:" \
      "Native 2560x1440 (no stretch)" \
      "1920x1440 (4:3, stretched)" \
      "1920x1200 (16:10, stretched)" \
      "Custom"
    case $REPLY in
      1) GAME_W=2560; GAME_H=1440; STRETCH_FLAG="none" ;;
      2) GAME_W=1920; GAME_H=1440; STRETCH_FLAG="stretch" ;;
      3) GAME_W=1920; GAME_H=1200; STRETCH_FLAG="stretch" ;;
      4) ;;
    esac
  elif [[ $NATIVE_W -eq 3840 && $NATIVE_H -eq 2160 ]]; then
    echo "Resolution profile for 4K 16:9:"
    prompt_select "Choose profile:" \
      "Native 3840x2160 (no stretch)" \
      "2560x1440 (downscale, no stretch)" \
      "1920x1440 (4:3, stretched)" \
      "1920x1200 (16:10, stretched)" \
      "Custom"
    case $REPLY in
      1) GAME_W=3840; GAME_H=2160; STRETCH_FLAG="none" ;;
      2) GAME_W=2560; GAME_H=1440; STRETCH_FLAG="none" ;;
      3) GAME_W=1920; GAME_H=1440; STRETCH_FLAG="stretch" ;;
      4) GAME_W=1920; GAME_H=1200; STRETCH_FLAG="stretch" ;;
      5) ;;
    esac
  fi

  local default_str="${GAME_W}x${GAME_H}"
  local resp
  resp=$(read_default "Internal GAME resolution WxH (gamescope -w/-h)" "$default_str")
  if [[ "$resp" =~ ^([0-9]+)x([0-9]+)$ ]]; then
    GAME_W=${BASH_REMATCH[1]}
    GAME_H=${BASH_REMATCH[2]}
  else
    echo "Invalid format; keeping $default_str."
  fi

  echo
  echo "Game resolution: ${GAME_W}x${GAME_H}"
  echo "Stretch flag:    ${STRETCH_FLAG}"
  echo
}

choose_gamescope_rate() {
  local val
  val=$(read_default "Target display refresh for gamescope (-r, Hz, 0 = unlimited)" "$G_FPS")
  if [[ ! "$val" =~ ^[0-9]+$ ]]; then
    echo "Invalid value; using 0."
    val=0
  fi
  G_FPS=$val
}

choose_vrr_hdr_and_steamos() {
  echo "Optional gamescope features:"

  # VRR / adaptive sync
  local vrr
  vrr=$(read_default "Enable gamescope adaptive sync / VRR? (0 = no, 1 = yes)" "$ADAPTIVE_SYNC")
  if [[ "$vrr" == "1" ]]; then
    ADAPTIVE_SYNC=1
  else
    ADAPTIVE_SYNC=0
  fi

  # HDR
  local hdr
  hdr=$(read_default "Enable gamescope HDR output? (0 = no, 1 = yes)" "$ENABLE_GAMESCOPE_HDR")
  if [[ "$hdr" == "1" ]]; then
    ENABLE_GAMESCOPE_HDR=1
    local nits
    nits=$(read_default "HDR ITM target nits (gamescope --hdr-itm-target-nits)" "$GAMESCOPE_HDR_NITS")
    if [[ "$nits" =~ ^[0-9]+$ ]]; then
      GAMESCOPE_HDR_NITS=$nits
    else
      echo "Invalid nits value; keeping $GAMESCOPE_HDR_NITS."
    fi
  else
    ENABLE_GAMESCOPE_HDR=0
  fi

  echo
  echo "Cursor grab:"
  echo "  Mostly useful on bare TTY (KMS). In nested sessions it can make"
  echo "  mouse input worse if games + overlays already manage grabs."
  local fg
  fg=$(read_default "Force gamescope cursor grab in KMS mode? (0 = no, 1 = yes)" "$FORCE_GRAB_CURSOR")
  if [[ "$fg" == "1" ]]; then
    FORCE_GRAB_CURSOR=1
  else
    FORCE_GRAB_CURSOR=0
  fi

  echo
}

choose_pipewire_debug() {
  echo "PipeWire / gamescope log verbosity:"
  echo "  This controls PIPEWIRE_DEBUG for the gamescope process only."
  echo "  Lower values reduce spam like 'pipewire: warning: out of buffers'."
  echo
  prompt_select "Choose PipeWire debug level:" \
    "Inherit system default (do not set PIPEWIRE_DEBUG)" \
    "Quiet: errors only [PIPEWIRE_DEBUG=0]" \
    "Errors + warnings [PIPEWIRE_DEBUG=1]" \
    "Info (more detail) [PIPEWIRE_DEBUG=2]" \
    "Verbose debug [PIPEWIRE_DEBUG=3]"

  case $REPLY in
    1) PIPEWIRE_DEBUG_MODE="inherit" ;;
    2) PIPEWIRE_DEBUG_MODE="0" ;;
    3) PIPEWIRE_DEBUG_MODE="1" ;;
    4) PIPEWIRE_DEBUG_MODE="2" ;;
    5) PIPEWIRE_DEBUG_MODE="3" ;;
    *) PIPEWIRE_DEBUG_MODE="inherit" ;;
  esac

  echo
  echo "PipeWire debug mode set to: $PIPEWIRE_DEBUG_MODE"
  echo "  inherit  = smtty leaves PIPEWIRE_DEBUG alone"
  echo "  0        = only errors (very quiet)"
  echo "  1        = errors + warnings"
  echo "  2        = info"
  echo "  3        = verbose debug"
  echo
}

# ---------------- Steam installation detection ----------------
detect_steam_installations() {
  local available=()
  local have_native=0
  local have_flatpak=0

  # Check for native Steam
  if command -v steam >/dev/null 2>&1; then
    available+=("Native Steam (steam)")
    have_native=1
  fi

  # Check for Flatpak Steam
  if command -v flatpak >/dev/null 2>&1 && \
     flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
    available+=("Steam Flatpak (com.valvesoftware.Steam)")
    have_flatpak=1
  fi

  if (( ${#available[@]} == 0 )); then
    echo "Error: No Steam installation found."
    echo "Please install Steam (native) or Steam Flatpak."
    exit 1
  fi

  # If only one option is available, use it automatically
  if (( ${#available[@]} == 1 )); then
    if (( have_native )); then
      STEAM_TYPE="native"
      echo "Detected: Native Steam"
    elif (( have_flatpak )); then
      STEAM_TYPE="flatpak"
      echo "Detected: Steam Flatpak"
    else
      echo "Internal error: Unknown Steam type despite one available."
      exit 1
    fi
    echo
    return
  fi

  # Multiple options available, let user choose
  echo "Multiple Steam installations detected:"
  prompt_select "Choose Steam installation:" "${available[@]}"

  if (( REPLY == 1 )); then
    STEAM_TYPE="native"
  else
    STEAM_TYPE="flatpak"
  fi

  echo
  echo "Using: ${available[REPLY-1]}"
  echo
}

configure_steam_command() {
  # If user set override, leave it alone
  if [[ -n "${STEAM_CMD_OVERRIDE-}" ]]; then
    return
  fi

  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    STEAM_CMD_ARR=(flatpak run com.valvesoftware.Steam -gamepadui)
  else
    STEAM_CMD_ARR=(steam -gamepadui)
  fi
}

# ---------------- gamescope deps ----------------
check_deps() {
  MISSING_CMDS=()
  require_cmd gamescope

  # Check Steam based on type
  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    require_cmd flatpak
    # Verify the Steam flatpak is actually installed
    if ! flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      echo "Error: Steam Flatpak (com.valvesoftware.Steam) is not installed."
      exit 1
    fi
  else
    require_cmd steam
  fi

  if ((${#MISSING_CMDS[@]} > 0)); then
    echo "Missing required commands:"
    printf '  - %s\n' "${MISSING_CMDS[@]}"
    echo
    echo "Install the missing utilities with your package manager."
    exit 1
  fi
}

launch_gamescope_session() {
  configure_steam_command
  check_deps

  echo
  echo "Launching gamescope:"
  echo "  Session mode:          $SESSION_MODE (kms = bare VT, nested = under compositor)"
  echo "  Steam type:            ${STEAM_TYPE:-native}"
  echo "  DRM output:            $DRM_SHORT"
  echo "  Outer (panel/native):  ${NATIVE_W}x${NATIVE_H}"
  echo "  Inner (game):          ${GAME_W}x${GAME_H}"
  echo "  Stretch mode:          ${STRETCH_FLAG}"
  echo "  Target refresh:        ${G_FPS} Hz (gamescope -r, 0 = unlimited)"
  echo "  Adaptive sync (VRR):   ${ADAPTIVE_SYNC}"
  echo "  HDR enabled:           ${ENABLE_GAMESCOPE_HDR}"
  echo "  HDR ITM target nits:   ${GAMESCOPE_HDR_NITS}"
  echo "  Force cursor grab:     ${FORCE_GRAB_CURSOR} (KMS only)"
  echo "  PipeWire debug mode:   ${PIPEWIRE_DEBUG_MODE}"
  echo "  Detach mode:           ${FLAG_DETACH}"
  echo

  local args=()
  args+=(-f -e)
  args+=(-W "$NATIVE_W" -H "$NATIVE_H")
  args+=(-w "$GAME_W" -h "$GAME_H")

  # KMS-only output selection
  if [[ "$SESSION_MODE" == "kms" ]]; then
    args+=(-O "$DRM_SHORT")
  fi

  if (( G_FPS > 0 )); then
    args+=(-r "$G_FPS")
  fi

  if [[ "$STRETCH_FLAG" == "stretch" ]]; then
    args+=(-S stretch)
  fi

  if (( ADAPTIVE_SYNC == 1 )); then
    args+=(--adaptive-sync)
  fi

  if (( ENABLE_GAMESCOPE_HDR == 1 )); then
    args+=(--hdr-enabled --hdr-itm-enable --hdr-itm-target-nits "$GAMESCOPE_HDR_NITS")
  fi

  # Only force grab in KMS mode; nested + overlays can break relative input
  if (( FORCE_GRAB_CURSOR == 1 )) && [[ "$SESSION_MODE" == "kms" ]]; then
    args+=(--force-grab-cursor)
  fi

  echo "Command:"
  printf 'gamescope'
  printf ' %q' "${args[@]}"
  printf ' --'
  printf ' %q' "${STEAM_CMD_ARR[@]}"
  printf '\n\n'

  # Apply PipeWire debug mode for gamescope only
  # "inherit" leaves PIPEWIRE_DEBUG unchanged (system/env default).
  # Any numeric value overrides it.
  if [[ "${PIPEWIRE_DEBUG_MODE:-inherit}" != "inherit" ]]; then
    export PIPEWIRE_DEBUG="$PIPEWIRE_DEBUG_MODE"
  fi

  if (( FLAG_DETACH )); then
    # Detached mode: run gamescope in background, detach from terminal.
    # Requires "setsid" (usually in util-linux).
    if command -v setsid >/dev/null 2>&1; then
      setsid gamescope "${args[@]}" -- "${STEAM_CMD_ARR[@]}" >/dev/null 2>&1 &
    else
      gamescope "${args[@]}" -- "${STEAM_CMD_ARR[@]}" >/dev/null 2>&1 &
    fi
    echo "gamescope started in detached mode with PID $!."
    echo "Use 'smtty -k' to kill any running gamescope processes."
    exit 0
  else
    exec gamescope "${args[@]}" -- "${STEAM_CMD_ARR[@]}"
  fi
}

interactive_new_config() {
  detect_session_mode
  detect_steam_installations
  choose_drm_output
  choose_resolution_profile
  choose_gamescope_rate
  choose_vrr_hdr_and_steamos
  choose_pipewire_debug
  save_config
  launch_gamescope_session
}

run_from_current_config() {
  detect_session_mode

  if [[ -z "$DRM_SHORT" || -z "$DRM_NATIVE_MODE" ]]; then
    echo "Config incomplete; re-running interactive setup."
    interactive_new_config
  fi

  # Set default if not set
  if [[ -z "${STEAM_TYPE:-}" ]]; then
    STEAM_TYPE="native"
  fi

  PIPEWIRE_DEBUG_MODE=${PIPEWIRE_DEBUG_MODE:-inherit}
  FORCE_GRAB_CURSOR=${FORCE_GRAB_CURSOR:-0}

  # Validate that the saved Steam type is still available
  if [[ "$STEAM_TYPE" == "flatpak" ]]; then
    if ! command -v flatpak >/dev/null 2>&1 || \
       ! flatpak list --app 2>/dev/null | grep -q "com.valvesoftware.Steam"; then
      echo "Warning: Saved config uses Steam Flatpak, but it's not available."
      detect_steam_installations
      save_config
    fi
  elif [[ "$STEAM_TYPE" == "native" ]]; then
    if ! command -v steam >/dev/null 2>&1; then
      echo "Warning: Saved config uses native Steam, but it's not available."
      detect_steam_installations
      save_config
    fi
  fi

  launch_gamescope_session
}

kill_gamescope() {
  if pkill gamescope >/dev/null 2>&1; then
    echo "Killed gamescope processes."
  else
    echo "No gamescope processes found."
  fi
}

# ---------------- main ----------------
if [[ ${UID:-$(id -u)} -eq 0 ]]; then
  echo "Do not run as root. Use your regular user account."
  exit 1
fi

while getopts ":hnlpkd" opt; do
  case "$opt" in
    h) FLAG_HELP=1 ;;
    n) FLAG_NEW=1 ;;
    l) FLAG_LAST=1 ;;
    p) FLAG_PRINT=1 ;;
    k) FLAG_KILL=1 ;;
    d) FLAG_DETACH=1 ;;
    \?) echo "Unknown option: -$OPTARG"; exit 1 ;;
  esac
done
shift $((OPTIND - 1))

if (( FLAG_HELP )); then
  print_help
  exit 0
fi

if (( FLAG_KILL )); then
  kill_gamescope
  exit 0
fi

load_config

if (( FLAG_PRINT )); then
  print_config_summary
  exit 0
fi

if (( FLAG_NEW )); then
  interactive_new_config
fi

if (( FLAG_LAST )); then
  if (( HAVE_CONFIG == 0 )); then
    echo "No saved config; doing new interactive setup."
    interactive_new_config
  else
    print_config_summary
    run_from_current_config
  fi
fi

if (( HAVE_CONFIG )); then
  detect_session_mode
  echo "Found saved smtty config."
  print_config_summary
  echo
  read -rp "Use last settings? [y/N]: " ans || exit 1
  case "$ans" in
    [yY]) run_from_current_config ;;
    *)    interactive_new_config ;;
  esac
else
  interactive_new_config
fi
